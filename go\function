问题 6.1：下面的函数将不会被编译，为什么呢？大家可以试着纠正过来。

func (st *Stack) Pop() int {
    v := 0
    for ix := len(st) - 1; ix >= 0; ix-- {
        if v = st[ix]; v != 0 {
            st[ix] = 0
            return v
        }
    }
}    

按引用传递的实质也是值传递
函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量
指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。
一般来讲，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少

传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回

Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。

reply *int

reply 是一个指向 int 变量的指针

一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移。


如下的两个函数调用有什么不同：

(A) func DoSomething(a *A) {
        b = a
    } 
    传递一个指向A类型的指针，b也是指针 指向a指向的数值

(B) func DoSomething(a A) {
        b = &a
    }
    
    传递一个A类型变量，b也是指针 指向啊指向的数值
    传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。
    
    
    非命名返回值与命名返回值
    
    任何一个非命名返回值（使用非命名返回值是很糟的编程习惯）在 return 语句里面都要明确指出包含返回值的变量或是一个可计算的值（就像上面警告所指出的那样）。
    
    
